#!/usr/bin/env bash
MY_NAME="[file_vulnerability.sh]"

if [[ "$PIPELINE_DEBUG" == 1 ]]; then
  trap env EXIT
  env
  set -x
fi

export ENVIRONMENT_TARGET=$(get_env target-environment "qa")

##
# set variables specific for CC pipeline
#
if [[ "cc" == ${PIPELINE_NAMESPACE} ]]; then

  # set timestamp for CC generated files
  #
  export DATETIME_UTC=$(date -u "+%Y%m%d%H%M%S")

  # Note: ${APP_REPO} is set by CI pipeline, but not CC pipeline
  #   This variable is used to locate the image inventory entry bound to the repo 
  #
  export APP_REPO=$(get_env one-pipeline-config-repo)

  # Note: CC pipeline sets ${COMMIT_SHA} as the code repo commit in use.
  #   Reset that to the commit used for generating the image per need.
  #
  # export COMMIT_SHA=$(get_env GIT_COMMIT)
  # echo "### ${MY_NAME} COMMIT_SHA: ${COMMIT_SHA}"

  # necessary COS related variables before "cocoa artifact upload" bug is fixed
  #
  export COS_API_KEY=$(get_env cos-api-key)
  export COS_ACCESS_KEY_ID=$(get_env cos-access-key-id)
  export COS_SECRET_ACCESS_KEY=$(get_env cos-secret-access-key)
  export COS_BUCKET_NAME=$(get_env cos-bucket-name)
  export COS_ENDPOINT=$(get_env cos-endpoint)  
fi

##
# Get evidence summary of the CI/CC pipeline
#
# Note: CI and CC pipelines use different means of getting evidence summary
#
export VULNERABILITY_FILENAME
if [[ "ci" == ${PIPELINE_NAMESPACE} ]]; then
  V2_SUMMARY_FILENAME="evidence_summary.json"
  CVE_SUMMARY_FILENAME="cve_summary.json"
  VULNERABILITY_FILENAME=cve.csv

  load_file ibm-devsecops-evidence-summary > ${V2_SUMMARY_FILENAME}
else # cc pipelinerun
  V2_SUMMARY_FILENAME="evidence_summary-${DATETIME_UTC}.json"
  CVE_SUMMARY_FILENAME="cve_summary-${DATETIME_UTC}.json"
  VULNERABILITY_FILENAME=cve-${DATETIME_UTC}.csv

  if [[ -n "$(get_env V2_SUMMARY_PATH)" ]]; then
    cp "$(get_env V2_SUMMARY_PATH)" ${V2_SUMMARY_FILENAME}
  else
    echo "*** ${MY_NAME} Undefined environment variable: V2_SUMMARY_PATH"
    exit
  fi
fi

##
# Reload latest commit of inventory repo for info on the target image
#
INVENTORY_PATH=${WORKSPACE}/inventory-repo
if [[ -d ${INVENTORY_PATH} ]] && [[ -d ${INVENTORY_PATH}/.git ]]; then
  pushd ${INVENTORY_PATH}
    git pull
  popd
else
  INVENTORY_PATH=${WORKSPACE}/$(get_env INVENTORY_REPO_NAME)
  pushd ${INVENTORY_PATH}
    git pull origin $(get_env target-environment)
  popd
fi
echo "*** ${MY_NAME} INVENTORY_PATH: ${INVENTORY_PATH}"


##
# Get image registry name (IMAGE_NAME)
#
CONCERT_VERSION=$(get_env concert-version "1.0.1")
while read -r filename; do
  inventory_file=${INVENTORY_PATH}/${filename}
  if [[ $(jq empty ${inventory_file} >/dev/null 2>&1; echo $?) == 0 ]]; then
    if [[ $(jq 'has("type")' ${inventory_file}) ]] \
        && [[ $(jq 'select(.type == "image")' ${inventory_file}) ]] \
        && [[ $(jq 'select(.repository_url == $ENV.APP_REPO)' ${inventory_file}) ]]; then
      
      inventory_obj=$(cat "${inventory_file}")
      export COMPONENT_NAME=$(echo ${inventory_obj} | jq -r '.name')
      export INVENTORY_BUILD=$(echo ${inventory_obj} | jq -r '.build_number')

      export IMAGE_URI=$(echo ${inventory_obj} | jq -r '.artifact')
      export IMAGE_PURL=${IMAGE_URI%@*}
      export IMAGE_NAME=${IMAGE_PURL%:*}
      export IMAGE_TAG=${IMAGE_PURL##*:}
      export IMAGE_DIGEST=${IMAGE_URI##*@}

      if [[ -z ${OUTPUTDIR} ]]; then
        mkdir -p ${CONCERT_DATA_PATH}/${INVENTORY_BUILD}/${ENVIRONMENT_TARGET}
        export OUTPUTDIR=${CONCERT_DATA_PATH}/${INVENTORY_BUILD}/${ENVIRONMENT_TARGET}
      fi

      if [[ ! -s ${V2_SUMMARY_FILENAME} ]]; then
        echo "### ${MY_NAME} Empty file (V2_SUMMARY_FILENAME): ${V2_SUMMARY_FILENAME}"
        exit
      elif [[ 0 != $(get_env if-devsecops-cos 0) ]]; then
        cocoa artifact upload \
          --backend="cos" \
          --namespace="$(get_env cos-namespace "cocoa")" \
          --pipeline-run-id="${COMPONENT_NAME}/${INVENTORY_BUILD}/${ENVIRONMENT_TARGET}" \
          --upload-path "${V2_SUMMARY_FILENAME}" \
          ${V2_SUMMARY_FILENAME}
      fi

      ##
      # Create JSON-formatted CVE summary of the CI/CC pipeline
      #
      jq '[.evidences[] | select(.evidence_type_id | test("vulnerability_scan")) 
        | del(.origin) |del(.issues) |del(.attachments)]' $V2_SUMMARY_FILENAME \
          > $CVE_SUMMARY_FILENAME

      if [[ ! -s ${CVE_SUMMARY_FILENAME} ]]; then
        echo "### ${MY_NAME} Empty file (CVE_SUMMARY_FILENAME): ${CVE_SUMMARY_FILENAME}"
        exit
      elif [[ 0 != $(get_env if-devsecops-cos 0) ]]; then
        cocoa artifact upload \
          --backend="cos" \
          --namespace="$(get_env cos-namespace "cocoa")" \
          --pipeline-run-id="${COMPONENT_NAME}/${INVENTORY_BUILD}/${ENVIRONMENT_TARGET}" \
          --upload-path "${CVE_SUMMARY_FILENAME}" \
          ${CVE_SUMMARY_FILENAME}
      fi

      ##
      # Generate CSV-formatted image CVEs
      #
      # ref: https://www.ibm.com/docs/en/concert?topic=vulnerabilities-supported-vulnerability-scan-formats
      # 
      if [[ ${CONCERT_VERSION} == "1.0.1" ]]; then
        cat > ${OUTPUTDIR}/${VULNERABILITY_FILENAME} << EOD
CVE,Image,Package,Package Version,Package Path,Severity,Score,hasFix,Fixed Version,Description,Tag,Digest
EOD
        jq '.[] | select(.evidence_type_id | test("image_vulnerability"))
          | .findings[] | "\(.id),\($ENV.IMAGE_NAME),n,n,n,\(.severity),0,n,n,n,\($ENV.IMAGE_TAG),\($ENV.IMAGE_DIGEST)"' $CVE_SUMMARY_FILENAME \
          | sed -e 's/^"//' -e 's/"$//'  \
          | sed -e 's/ (.*)//g' \
          >> ${OUTPUTDIR}/${VULNERABILITY_FILENAME}
      elif [[ ${CONCERT_VERSION} == "1.0.2" ]]; then
        echo "*** ${MY_NAME} Unsupported Concert version (WIP): ${CONCERT_VERSION}"
        exit 1
      else
        echo "*** ${MY_NAME} Unsupported Concert version: ${CONCERT_VERSION}"
        exit 1
      fi

      # Conditionally upload file to COS
      #
      if [[ -s ${OUTPUTDIR}/${VULNERABILITY_FILENAME} ]] \
          && [[ 0 != $(get_env concert-if-cos 0) ]]; then 
        cocoa artifact upload \
          --backend="cos" \
          --namespace="$(get_env cos-namespace "cocoa")" \
          --pipeline-run-id="${COMPONENT_NAME}/${INVENTORY_BUILD}/${ENVIRONMENT_TARGET}" \
          --upload-path "${VULNERABILITY_FILENAME}" \
          ${OUTPUTDIR}/${VULNERABILITY_FILENAME}
      fi

      # Upload file to Concert
      #
      envsubst < ${CONCERT_TEMPLATES_PATH}/vulnerability_load_config.yaml.template \
        > ${OUTPUTDIR}/config.yaml

      ${CONCERT_HELPERS_PATH}/concert_upload.sh --outputdir ${OUTPUTDIR}
      break
    fi
  fi
done < <(ls -1 ${INVENTORY_PATH})
